<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Updated title -->
  <title>Smart Plug Switcher - make your electric devices run on renewables with software</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <!-- Import Bootstrap CSS for styling and collapse functionality -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
  <!-- Import Orbitron font for a futuristic look; additional fonts will be loaded by the user settings -->
  <link href="https://fonts.googleapis.com/css?family=Corbel|Arial|Verdana|Tahoma&display=swap" rel="stylesheet">
  <!-- Import Plotly for interactive graphs -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body {
      background-color: #1a1a1a;
      color: #e0e0e0;
      /* Default to Corbel */
      font-family: 'Corbel', sans-serif;
      font-size: 16px;
    }
    h1, h2, h3, h5 {
      color: #f0f0f0;
    }
    .container {
      margin-top: 120px; /* leave room for fixed navbar and overall settings */
    }
    /* Navbar styling */
    .navbar-custom {
      background-color: #222222;
    }
    .navbar-custom .navbar-brand, .navbar-custom .nav-link, .navbar-custom .form-inline {
      color: #e0e0e0;
    }
    .navbar-custom .nav-link:hover {
      color: #00ff00;
    }
    /* Overall Settings Panel */
    .overall-settings {
      background-color: #333;
      color: #fff;
      padding: 10px 15px;
      border-radius: 5px;
      margin: 10px 0;
    }
    .overall-settings label {
      margin-right: 10px;
    }
    /* Collapsible Overview Sections */
    .overview-button {
      margin-bottom: 10px;
    }
    .overview-card {
      background-color: #333;
      color: #fff;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    /* Forecast and Smart Plug Settings take full width */
    #forecastSection, #smartPlugSettingsSection {
      margin-bottom: 40px;
    }
    /* Styling for the plug settings panel */
    #plugSchedulePanel {
      background: #2a2a2a;
      border: 1px solid #444;
      padding: 15px;
      border-radius: 5px;
    }
    .plugEntry {
      border: 1px solid #555;
      padding: 10px;
      margin-bottom: 10px;
      border-radius: 4px;
      background: #333;
    }
    .plugStatus {
      font-weight: bold;
      margin-top: 5px;
    }
    .form-text {
      font-size: 0.85rem;
      color: #b0b0b0;
    }
    /* Graph styling */
    #mergedGraph {
      border: 1px solid #444;
      padding: 10px;
      background: #121212;
      border-radius: 5px;
      width: 100%;
      height: 400px;
    }
    /* Timer styling */
    #refreshTimer {
      font-size: 1.5em;
      font-weight: bold;
      color: #00ff00;
      border: 2px solid #00ff00;
      border-radius: 5px;
      padding: 5px 10px;
      white-space: nowrap;
    }
    #timerLabel {
      font-size: 1em;
      color: #f0f0f0;
    }
    /* Advanced Settings styling */
    .plugAdvancedSettings {
      margin-top: 10px;
      padding: 10px;
      border: 1px solid #555;
      border-radius: 4px;
      background: #444;
    }
    .forcedRule {
      border: 1px solid #666;
      padding: 5px;
      margin-bottom: 5px;
      border-radius: 3px;
      background: #555;
    }
    .forcedRule input.form-control, 
    .forcedRule select.form-control {
      color: #e0e0e0;
      background-color: #444;
    }
  </style>
</head>
<body>
  <!-- Fixed Top Navbar -->
  <nav class="navbar navbar-expand-lg navbar-dark fixed-top navbar-custom" data-toggle="tooltip" title="Use the menu items and controls below to navigate and configure the dashboard.">
    <a class="navbar-brand" href="#">Airplane Dashboard</a>
    <div class="collapse navbar-collapse">
      <ul class="navbar-nav mr-auto">
        <li class="nav-item">
          <a class="nav-link" data-toggle="collapse" data-target="#dashboardOverview" title="Click to view details about this dashboard functionality.">Dashboard</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" data-toggle="collapse" data-target="#profitOverview" title="Click to view information on how this dashboard can save you money.">Profits</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" data-toggle="collapse" data-target="#recommendedDevices" title="Click to view recommended devices for smart plugs.">Devices</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" data-toggle="collapse" data-target="#usageGuide" title="Click to view the user guide.">Guide</a>
        </li>
      </ul>
      <div class="form-inline">
        <span id="timerLabel" class="mr-2">Next Forecast:</span>
        <span id="refreshTimer"></span>
      </div>
    </div>
  </nav>

  <!-- Overall Settings Panel -->
  <div class="container">
    <div class="overall-settings" data-toggle="tooltip" title="Change overall settings for the page here.">
      <div class="row">
        <div class="col-md-4">
          <label for="fontSelect">Font Family:</label>
          <select id="fontSelect" class="form-control form-control-sm">
            <option value="'Corbel', sans-serif" selected>Corbel</option>
            <option value="'Arial', sans-serif">Arial</option>
            <option value="'Verdana', sans-serif">Verdana</option>
            <option value="'Tahoma', sans-serif">Tahoma</option>
          </select>
        </div>
        <div class="col-md-4">
          <label for="fontSizeRange">Font Size:</label>
          <input type="range" id="fontSizeRange" min="12" max="24" value="16" class="form-control-range">
          <span id="fontSizeDisplay">16px</span>
        </div>
        <div class="col-md-4">
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="preventScreensaverToggleOverall" data-toggle="tooltip" title="Toggle to prevent your screen from sleeping.">
            <label class="form-check-label" for="preventScreensaverToggleOverall">Prevent Screensaver</label>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Rest of the page (Overview sections, location input, forecast, smart plug settings) -->
    
    <!-- Overview Sections -->
    <div class="row mb-3">
      <div class="col-md-6">
        <button class="btn btn-info btn-block overview-button" data-toggle="collapse" data-target="#dashboardOverview" aria-expanded="false" aria-controls="dashboardOverview" title="Click to view details about this dashboard functionality.">
          This Dashboard
        </button>
        <div class="collapse" id="dashboardOverview">
          <div class="overview-card">
            <h5>This Dashboard</h5>
            <p>
              This dashboard is a comprehensive, real-time control center designed to seamlessly integrate weather forecasting with smart plug scheduling, because you can save money while being more sustainable. Key features include:
            </p>
            <ul>
              <li><strong>Real-Time Weather Forecasting:</strong> Fetches weather data (such as wind speed at 80 m and Sun radiation) using your current or manually entered location. It computes a renewable energy quality score by balancing solar and wind energy inputs, displayed on an interactive Plotly graph.</li>
              <li><strong>Smart Plug Scheduling & Control:</strong> Configure smart plugs with custom on/off schedules based on user-planned or weather-optimized settings. Set parameters like on-hours, total cycle hours, device power (kWh), and forced on/off rules. Webhooks update plug status automatically.</li>
              <li><strong>Dynamic Updates & Continuous Operation:</strong> The dashboard runs continuously with self-refreshing weather forecasts, graph updates, and plug schedule checks.</li>
              <li><strong>Additional Utilities:</strong> Use an energy slider to adjust the balance between solar power and wind energy importance – tailor this if your area has more solar panels or wind turbines.</li>
            </ul>
          </div>
        </div>
      </div>
      <div class="col-md-6">
        <button class="btn btn-info btn-block overview-button" data-toggle="collapse" data-target="#profitOverview" aria-expanded="false" aria-controls="profitOverview" title="Click to view information on how this dashboard can save you money and help the environment.">
          Your Profits
        </button>
        <div class="collapse" id="profitOverview">
          <div class="overview-card">
            <h5>Your Profits</h5>
            <p>
              Using optimized scheduling, your device energy usage is shifted to the hours with the best renewable energy availability. This script compares your user-planned schedule with the optimized (weather-based) schedule over the complete forecast period to determine how many kWh can be rescheduled. This helps lower energy costs, reduce fossil fuel use, and help make the energy grid more efficient.
            </p>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Second Row: Recommended Devices and User Guide -->
    <div class="row mb-3">
      <div class="col-md-6">
        <button class="btn btn-info btn-block overview-button" data-toggle="collapse" data-target="#recommendedDevices" aria-expanded="false" aria-controls="recommendedDevices" title="Click to view a list of devices that are ideal for weather-based smart plugs.">
          Recommended Devices
        </button>
        <div class="collapse" id="recommendedDevices">
          <div class="overview-card">
            <h5>Recommended Devices</h5>
            <p>These devices are ideal candidates for weather-based smart plugs, as they do not need to be on 100% of the time:</p>
            <ul>
              <li>Standard Air Conditioners</li>
              <li>Home Battery Systems</li>
              <li>Electric Vehicle Chargers</li>
              <li>Refrigerators/Freezers</li>
              <li>Water Heaters</li>
              <li>Sump Pumps</li>
              <li>Hot Tubs/Spas</li>
              <li>Heated Floors</li>
              <li>Air Purifiers</li>
              <li>Dehumidifiers/Humidifiers</li>
              <li>Electric Space Heaters</li>
              <li>Fans</li>
              <li>Fish Tank Heaters, Pumps and Filters</li>
              <li>Industrial Equipment</li>
              <li>Electric Water Pumps</li>
              <li>Irrigation Systems</li>
              <li>Pool Pumps</li>
            </ul>
          </div>
        </div>
      </div>
      <div class="col-md-6">
        <button class="btn btn-info btn-block overview-button" data-toggle="collapse" data-target="#usageGuide" aria-expanded="false" aria-controls="usageGuide" title="Click to view a step-by-step guide on how to use this page.">
          User Guide
        </button>
        <div class="collapse" id="usageGuide">
          <div class="overview-card">
            <h5>User Guide</h5>
            <ol>
              <li><strong>Set Your Location:</strong> Use automatic geolocation or enter your village/city manually to fetch weather data.</li>
              <li><strong>Click Retrieve Weather:</strong> Click "Retrieve Weather" to update the forecast and initialize the dashboard.</li>
              <li><strong>Adjust the Energy Slider:</strong> Choose your desired balance between solar power and wind energy. Choose wisely if your area has more solar panels or more wind turbines.</li>
              <li><strong>Add your smart plug:</strong> Set on-hours, total cycle hours, device power (kWh), and webhooks for each plug. Optionally, add forced rules.</li>
              <li><strong>Select a Schedule Type:</strong> Choose between <strong>User Planned</strong> and <strong>Optimized (Weather-based)</strong> schedules. <em>Optimized</em> is now the default – all plugs will follow the same optimized schedule as shown in the graph.</li>
              <li><strong>Review Your Profit Forecast:</strong> See the dynamic "Profit forecast" showing the total rescheduled energy over the forecast period.</li>
              <li><strong>Save/Load Settings:</strong> Use the buttons to save your configuration or load a previous one.</li>
            </ol>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Settings Controls (Save/Load already in navbar remain here as well) -->
    <div id="settingsButtons" class="mb-3 d-flex justify-content-between align-items-center">
      <div>
        <button class="btn btn-success" id="saveSettingsBtn" data-toggle="tooltip" title="Save your current configuration.">Save Settings</button>
        <button class="btn btn-warning" id="loadSettingsBtn" data-toggle="tooltip" title="Load your previously saved configuration.">Load Settings</button>
      </div>
    </div>
    
    <!-- Location Display and Manual Input -->
    <div id="locationDisplay" class="mt-3" data-toggle="tooltip" title="This area displays your current location information.">
      <p>Location will appear here when retrieved.</p>
    </div>
    <button id="getGeoBtn" class="btn btn-primary mb-3" data-toggle="tooltip" title="Click to automatically retrieve your location.">Get Geolocation Automatically</button>
    <h2 class="mt-5" data-toggle="tooltip" title="Enter your village or city to get the weather forecast.">Enter Location Manually</h2>
    <form id="locationForm">
      <div class="form-group">
        <input type="text" class="form-control" id="manualLocation" placeholder="Enter village or city name" required data-toggle="tooltip" title="Type your village or city name here.">
        <small class="form-text" data-toggle="tooltip" title="Your village or city name will be used to fetch weather data.">Type the name of your village or city to fetch coordinates and weather.</small>
      </div>
      <div id="timerContainer">
        <button type="submit" class="btn btn-secondary" data-toggle="tooltip" title="Click to retrieve weather data for your location.">Retrieve Weather</button>
        <div id="timerLabel">Next Forecast Refresh:</div>
        <div id="refreshTimer"></div>
      </div>
    </form>
    <div id="manualLocationResult" class="mt-3" data-toggle="tooltip" title="This area shows the results of your manual location search."></div>
    
    <!-- Forecast Section -->
    <div id="forecastSection" class="mt-5">
      <h3 data-toggle="tooltip" title="This section displays the weather forecast and renewable energy quality.">Weather & Renewable Energy Forecast</h3>
      <div class="form-group">
        <label for="energySlider" data-toggle="tooltip" title="Adjust the slider to balance the availability of either solar panels or wind turbines in your area.">
          My area has: <span id="sunWeightLabel">50</span>% Solar Panels / <span id="windWeightLabel">50</span>% Wind Turbines
        </label>
        <input type="range" class="form-control-range" id="energySlider" min="0" max="100" value="50" data-toggle="tooltip" title="Slide to adjust the relative availability of either solar panels or wind turbines around your location.">
        <small class="form-text" data-toggle="tooltip" title="Adjusting this slider updates the renewable energy quality calculation.">Adjust the slider to set the weighting between solar panel availability vs wind turbines.</small>
      </div>
      <div id="mergedGraph" data-toggle="tooltip" title="Interactive graph showing weather forecast, renewable energy quality, and plug schedules."></div>
    </div>
    
    <!-- Smart Plug Settings Section -->
    <div id="smartPlugSettingsSection" class="mt-5">
      <h3 class="text-center" data-toggle="tooltip" title="Configure your smart plug settings below.">Smart Plug Settings</h3>
      <div class="row">
        <div class="col-md-6">
          <label data-toggle="tooltip" title="Select your preferred scheduling method.">Schedule Type:</label>
          <div class="form-check">
            <input class="form-check-input" type="radio" name="scheduleType" id="userPlanned" value="user" data-toggle="tooltip" title="User Planned: Your plug will be on at the times you specified.">
            <label class="form-check-label" for="userPlanned">User Planned</label>
          </div>
          <div class="form-check">
            <!-- Optimized is default -->
            <input class="form-check-input" type="radio" name="scheduleType" id="optimized" value="optimized" checked data-toggle="tooltip" title="Optimized (Weather-based): The plug's on-hour is shifted to the most renewable hour.">
            <label class="form-check-label" for="optimized">Optimized (Weather-based)</label>
          </div>
        </div>
        <div class="col-md-6">
          <div class="card bg-dark text-white">
            <div class="card-body text-center">
              <h5 class="card-title" data-toggle="tooltip" title="This shows the total energy (in kWh) rescheduled to renewables over the forecast period.">The Profit Forecast</h5>
              <div id="profitInfographicValue" data-toggle="tooltip" title="This value updates dynamically as your plug schedules change.">
                <p>0.00 kWh</p>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div id="plugSchedulePanel" data-toggle="tooltip" title="Configure each smart plug's settings below.">
        <div id="plugList"></div>
        <button type="button" class="btn btn-outline-secondary mb-2" id="addPlugBtn" data-toggle="tooltip" title="Click to add a new smart plug configuration.">Add Plug</button>
        <small class="form-text mb-2" data-toggle="tooltip" title="Click 'Add Plug' and then fill in the details for each plug.">Click "Add Plug" to add a new smart plug. Fill in the details below for each plug.</small>
        <button type="button" class="btn btn-info btn-block" id="updatePlugsBtn" data-toggle="tooltip" title="Click to update the plug schedules and recalculate the profit forecast.">Update Plug Schedules</button>
      </div>
    </div>
  </div>
  
  <!-- Import jQuery and Bootstrap JS -->
  <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.bundle.min.js"></script>
  <script>
    // Initialize Bootstrap tooltips
    $(function () {
      $('[data-toggle="tooltip"]').tooltip();
    });
    
    /*************************************
     * 1) GLOBAL VARIABLES & TIMER SETUP *
     *************************************/
    let weatherTimeData = null;
    let weatherWindData = null;
    let weatherUvData = null;
    let globalLineTraces = [];
    let globalMergedLayout = null;
    let lastWeatherUpdate = null;
    let chartInitialized = false;
    
    // Timer for forecast refresh countdown
    function updateTimer() {
      const now = new Date();
      const nextHour = new Date(now);
      nextHour.setMinutes(0, 0, 0);
      nextHour.setHours(now.getHours() + 1);
      const diff = nextHour - now;
      const seconds = Math.floor(diff / 1000) % 60;
      const minutes = Math.floor(diff / (1000 * 60)) % 60;
      const hours = Math.floor(diff / (1000 * 60 * 60));
      document.getElementById('refreshTimer').innerText =
        (hours < 10 ? "0" + hours : hours) + ":" +
        (minutes < 10 ? "0" + minutes : minutes) + ":" +
        (seconds < 10 ? "0" + seconds : seconds);
    }
    setInterval(updateTimer, 1000);
    updateTimer();
    
    /**************************************
     * 2) SAVE/LOAD SETTINGS FROM STORAGE *
     **************************************/
    function saveSettings() {
      const settings = {
        manualLocation: document.getElementById('manualLocation').value,
        energySlider: document.getElementById('energySlider').value,
        scheduleType: document.querySelector('input[name="scheduleType"]:checked').value,
        plugs: []
      };
      const plugEntries = document.querySelectorAll('.plugEntry');
      plugEntries.forEach(entry => {
        const plug = {
          name: entry.querySelector('.plugName').value,
          onHours: entry.querySelector('.plugOnHours').value,
          totalHours: entry.querySelector('.plugTotalHours').value,
          kwh: entry.querySelector('.plugKwh').value,
          webhookOn: entry.querySelector('.webhookOn').value,
          webhookOff: entry.querySelector('.webhookOff').value,
          forcedRules: []
        };
        entry.querySelectorAll('.forcedRule').forEach(rule => {
          const daysSelect = rule.querySelector('.forcedRuleDays');
          const selectedDays = Array.from(daysSelect.selectedOptions).map(opt => opt.value);
          plug.forcedRules.push({
            days: selectedDays,
            start: rule.querySelector('.forcedRuleStart').value,
            end: rule.querySelector('.forcedRuleEnd').value,
            state: rule.querySelector('.forcedRuleState').value
          });
        });
        settings.plugs.push(plug);
      });
      localStorage.setItem("dashboardSettings", JSON.stringify(settings));
      alert("Settings saved.");
    }
    
    function loadSettings() {
      const settingsStr = localStorage.getItem("dashboardSettings");
      if (!settingsStr) { alert("No settings found."); return; }
      const settings = JSON.parse(settingsStr);
      document.getElementById('manualLocation').value = settings.manualLocation;
      document.getElementById('energySlider').value = settings.energySlider;
      document.getElementById('sunWeightLabel').textContent = settings.energySlider;
      document.getElementById('windWeightLabel').textContent = 100 - settings.energySlider;
      document.querySelector(`input[name="scheduleType"][value="${settings.scheduleType}"]`).checked = true;
      const plugList = document.getElementById('plugList');
      plugList.innerHTML = "";
      settings.plugs.forEach((plug) => { addPlug(plug); });
      alert("Settings loaded.");
      document.getElementById("locationForm").dispatchEvent(new Event('submit'));
    }
    
    document.getElementById('saveSettingsBtn').addEventListener('click', saveSettings);
    document.getElementById('loadSettingsBtn').addEventListener('click', loadSettings);
    
    /****************************************
     * 3) GEOLOCATION & WEATHER RETRIEVAL    *
     ****************************************/
    function setLocationDisplay(data, latitude, longitude) {
      const address = data.address || {};
      const place = address.city || address.town || address.village || address.hamlet || "";
      let displayText = `Your coordinates: Latitude: ${latitude.toFixed(4)}, Longitude: ${longitude.toFixed(4)}`;
      if (place) { displayText += `<br>Location: ${place}`; }
      if (address.country) { displayText += `<br>Country: ${address.country}`; }
      document.getElementById('locationDisplay').innerHTML = `<p>${displayText}</p>`;
      const manualField = document.getElementById('manualLocation');
      if (!manualField.value && place) { manualField.value = place; }
    }
    
    function getGeoLocation() {
      const locationDisplay = document.getElementById('locationDisplay');
      locationDisplay.innerHTML = '<p>Retrieving your location...</p>';
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(function(position) {
          const latitude = position.coords.latitude;
          const longitude = position.coords.longitude;
          const reverseUrl = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}&addressdetails=1`;
          fetch(reverseUrl)
            .then(response => response.json())
            .then(data => { setLocationDisplay(data, latitude, longitude); })
            .catch(error => { locationDisplay.innerHTML = `<p>Your coordinates: Latitude: ${latitude.toFixed(4)}, Longitude: ${longitude.toFixed(4)}</p>`; });
        }, function(error) { locationDisplay.innerHTML = `<p>Error getting location: ${error.message}</p>`; });
      } else {
        locationDisplay.innerHTML = '<p>Geolocation is not supported by this browser.</p>';
      }
    }
    
    document.getElementById('getGeoBtn').addEventListener('click', getGeoLocation);
    
    document.getElementById('locationForm').addEventListener('submit', function(e) {
      e.preventDefault();
      const locationName = document.getElementById('manualLocation').value;
      const manualLocationResult = document.getElementById('manualLocationResult');
      manualLocationResult.innerHTML = '<p>Converting location to coordinates...</p>';
      const url = `https://nominatim.openstreetmap.org/search?format=json&addressdetails=1&limit=1&q=${encodeURIComponent(locationName)}`;
      fetch(url)
        .then(response => response.json())
        .then(data => {
          if (data && data.length > 0) {
            const lat = data[0].lat;
            const lon = data[0].lon;
            const country = (data[0].address && data[0].address.country) ? data[0].address.country : '';
            manualLocationResult.innerHTML = `<p>Coordinates for ${locationName}: Latitude: ${parseFloat(lat).toFixed(4)}, Longitude: ${parseFloat(lon).toFixed(4)}${country ? `<br>Country: ${country}` : ""}</p>`;
            const weatherUrl = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=uv_index,wind_speed_80m&forecast_days=3&past_days=1&timezone=Europe%2FAmsterdam&location_mode=csv_coordinates`;
            fetch(weatherUrl)
              .then(response => response.json())
              .then(weatherData => {
                if (weatherData && weatherData.hourly && weatherData.hourly.time) {
                  weatherTimeData = weatherData.hourly.time;
                  weatherWindData = weatherData.hourly.wind_speed_80m;
                  weatherUvData = weatherData.hourly.uv_index;
                  lastWeatherUpdate = new Date();
                  const traceWind = {
                    x: weatherTimeData,
                    y: weatherWindData,
                    mode: 'lines',
                    name: 'Wind Speed at 80m (m/s)',
                    yaxis: 'y1'
                  };
                  const traceSun = {
                    x: weatherTimeData,
                    y: weatherUvData,
                    mode: 'lines',
                    name: 'Sun radiation',
                    yaxis: 'y2'
                  };
                  const weight = parseInt(document.getElementById('energySlider').value, 10) / 100;
                  const computeRenewable = w => weatherTimeData.map((_, i) => w * parseFloat(weatherUvData[i]) + (1 - w) * parseFloat(weatherWindData[i]));
                  const traceRenewable = {
                    x: weatherTimeData,
                    y: computeRenewable(weight),
                    mode: 'lines',
                    name: 'Renewable Energy Quality',
                    yaxis: 'y3'
                  };
                  globalLineTraces = [traceWind, traceSun, traceRenewable];
                  
                  globalMergedLayout = {
                    paper_bgcolor: '#222222',
                    plot_bgcolor: '#222222',
                    font: { color: '#ffffff', family: 'Orbitron, sans-serif', size: 10 },
                    title: {
                      text: 'Forecast, Renewable Energy & Plug Schedule (Toggle traces via legend)',
                      font: { size: 12, color: '#ffffff', family: 'Orbitron, sans-serif' }
                    },
                    xaxis: { 
                      title: 'Time',
                      tickangle: -45,
                      automargin: true,
                      tickfont: { size: 12 },
                      rangeselector: {
                        bgcolor: '#444',
                        activecolor: '#00aa00',
                        font: { color: '#ffffff', size: 10 },
                        buttons: [
                          {count: 6, label: '6h', step: 'hour', stepmode: 'backward'},
                          {count: 12, label: '12h', step: 'hour', stepmode: 'backward'},
                          {count: 1, label: '1d', step: 'day', stepmode: 'backward'},
                          {step: 'all'}
                        ]
                      },
                      rangeslider: {}
                    },
                    yaxis: {
                      title: 'Wind Speed (m/s)',
                      automargin: true,
                      title_standoff: 10,
                      tickfont: { size: 9 }
                    },
                    yaxis2: {
                      title: 'Sun radiation',
                      overlaying: 'y',
                      side: 'right',
                      automargin: true,
                      title_standoff: 10,
                      tickfont: { size: 9 }
                    },
                    yaxis3: {
                      title: 'Renewable Energy Score',
                      anchor: 'free',
                      overlaying: 'y',
                      side: 'left',
                      position: 0.04,
                      automargin: true,
                      title_standoff: 10,
                      tickfont: { size: 9 }
                    },
                    legend: {
                      orientation: 'v',
                      x: 1.02,
                      y: 1,
                      xanchor: 'left',
                      font: { size: 9 },
                      bgcolor: '#333333'
                    },
                    barmode: 'stack',
                    hovermode: 'closest',
                    height: 400,
                    margin: { l: 50, r: 100, t: 60, b: 70 }
                  };
                  
                  if (chartInitialized) {
                    Plotly.react('mergedGraph', globalLineTraces, globalMergedLayout, { responsive: true });
                  } else {
                    Plotly.newPlot('mergedGraph', globalLineTraces, globalMergedLayout, { responsive: true });
                    chartInitialized = true;
                  }
                  updatePlugSchedules();
                  checkPlugStates();
                  updateProfitInfographic();
                } else {
                  document.getElementById('mergedGraph').innerHTML = '<p>No weather data available for the selected period.</p>';
                }
              })
              .catch(error => { document.getElementById('mergedGraph').innerHTML = `<p>Error fetching weather data: ${error.message}</p>`; });
          } else {
            manualLocationResult.innerHTML = `<p>No results found for "${locationName}".</p>`;
          }
        })
        .catch(error => { manualLocationResult.innerHTML = `<p>Error converting location: ${error.message}</p>`; });
    });
    
    /*******************************************
     * 4) ENERGY SLIDER & PLUG SCHEDULE UPDATE  *
     *******************************************/
    document.getElementById('energySlider').addEventListener('input', function() {
      const sliderValue = parseInt(this.value, 10);
      document.getElementById('sunWeightLabel').textContent = sliderValue;
      document.getElementById('windWeightLabel').textContent = 100 - sliderValue;
      if (!weatherTimeData || !weatherWindData || !weatherUvData) return;
      const weight = sliderValue / 100;
      const newRenewable = weatherTimeData.map((_, i) => weight * parseFloat(weatherUvData[i]) + (1 - weight) * parseFloat(weatherWindData[i]));
      Plotly.restyle('mergedGraph', { y: [newRenewable] }, [2]);
      if (document.querySelector('input[name="scheduleType"]:checked').value === "optimized") {
        updatePlugSchedules();
        checkPlugStates();
        updateProfitInfographic();
      }
    });
    
    document.querySelectorAll('input[name="scheduleType"]').forEach(radio => {
      radio.addEventListener('change', function() {
        updatePlugSchedules();
        checkPlugStates();
        updateProfitInfographic();
      });
    });
    
    function groupTimesByDay(timeData) {
      const groups = {};
      timeData.forEach((t, i) => {
        let date = t.split("T")[0];
        if (!groups[date]) groups[date] = { times: [], indices: [] };
        groups[date].times.push(t);
        groups[date].indices.push(i);
      });
      const sortedDates = Object.keys(groups).sort();
      return sortedDates.map(date => groups[date]);
    }
    
    function computePlugScheduleForDay(onHours, totalHours, dayTimes) {
      const dayLength = dayTimes.length;
      function computeCycle(onHours, totalHours) {
        onHours = Math.min(onHours, totalHours);
        let pattern = new Array(totalHours).fill(0);
        let positions = [];
        for (let i = 0; i < onHours; i++) {
          let pos = Math.round((i + 0.5) * totalHours / onHours - 0.5);
          if (pos < 0) pos = 0;
          if (pos >= totalHours) pos = totalHours - 1;
          positions.push(pos);
        }
        positions.forEach(p => { pattern[p] = 1; });
        return pattern;
      }
      const cycle = computeCycle(onHours, totalHours);
      let schedule = [];
      const cycles = Math.floor(dayLength / totalHours);
      const remainder = dayLength % totalHours;
      for (let i = 0; i < cycles; i++) { schedule = schedule.concat(cycle); }
      schedule = schedule.concat(cycle.slice(0, remainder));
      return schedule;
    }
    
    function computeOptimalPlugScheduleForDay(onHours, totalHours, dayGroup, weight) {
      const dayTimes = dayGroup.times;
      const indices = dayGroup.indices;
      const dayLength = dayTimes.length;
      let schedule = [];
      const cycles = Math.floor(dayLength / totalHours);
      const remainder = dayLength % totalHours;
      for (let c = 0; c < cycles; c++) {
        const cycleIndices = indices.slice(c * totalHours, (c + 1) * totalHours);
        const qualityCycle = cycleIndices.map(i => weight * parseFloat(weatherUvData[i]) + (1 - weight) * parseFloat(weatherWindData[i]));
        let pattern = new Array(totalHours).fill(0);
        let idxs = Array.from({length: totalHours}, (_, idx) => idx);
        idxs.sort((a, b) => qualityCycle[b] - qualityCycle[a]);
        for (let k = 0; k < Math.min(onHours, totalHours); k++) { pattern[idxs[k]] = 1; }
        schedule = schedule.concat(pattern);
      }
      if (remainder > 0) {
        const cycleIndices = indices.slice(cycles * totalHours);
        const qualityCycle = cycleIndices.map(i => weight * parseFloat(weatherUvData[i]) + (1 - weight) * parseFloat(weatherWindData[i]));
        let pattern = new Array(remainder).fill(0);
        let idxs = Array.from({length: remainder}, (_, idx) => idx);
        idxs.sort((a, b) => qualityCycle[b] - qualityCycle[a]);
        for (let k = 0; k < Math.min(onHours, remainder); k++) { pattern[idxs[k]] = 1; }
        schedule = schedule.concat(pattern);
      }
      return schedule;
    }
    
    function applyForcedRules(entry, schedule) {
      const forcedRules = entry.querySelectorAll('.forcedRule');
      forcedRules.forEach(rule => {
        const daysSelect = rule.querySelector('.forcedRuleDays');
        const selectedDays = Array.from(daysSelect.selectedOptions).map(opt => opt.value);
        const startTime = rule.querySelector('.forcedRuleStart').value;
        const endTime = rule.querySelector('.forcedRuleEnd').value;
        const forcedState = rule.querySelector('.forcedRuleState').value;
        schedule = schedule.map((val, index) => {
          const ts = new Date(weatherTimeData[index]);
          const dayName = ts.toLocaleDateString('en-US', { weekday: 'short' });
          if (!selectedDays.includes(dayName)) return val;
          const minutes = ts.getHours() * 60 + ts.getMinutes();
          const [startH, startM] = startTime.split(':').map(Number);
          const [endH, endM] = endTime.split(':').map(Number);
          const startMinutes = startH * 60 + startM;
          const endMinutes = endH * 60 + endM;
          let inInterval = (startMinutes <= endMinutes)
                           ? (minutes >= startMinutes && minutes < endMinutes)
                           : (minutes >= startMinutes || minutes < endMinutes);
          if (inInterval) return forcedState === "on" ? 1 : 0;
          return val;
        });
      });
      return schedule;
    }
    
    function addPlug(plugData = null) {
      const plugList = document.getElementById('plugList');
      const plugIndex = plugList.children.length + 1;
      const plugDiv = document.createElement('div');
      plugDiv.className = 'plugEntry';
      plugDiv.innerHTML = `
        <div class="form-group">
          <input type="text" class="form-control plugName" placeholder="Plug Name" value="${plugData ? plugData.name : "Plug " + plugIndex}" data-toggle="tooltip" title="Enter a unique name for this plug.">
          <small class="form-text" data-toggle="tooltip" title="This name helps you identify the plug.">Enter a unique name for this smart plug.</small>
        </div>
        <div class="form-row">
          <div class="col">
            <input type="number" class="form-control plugOnHours" placeholder="On Hours" min="0" value="${plugData ? plugData.onHours : 4}" data-toggle="tooltip" title="Enter the number of hours this plug should be ON per cycle.">
            <small class="form-text" data-toggle="tooltip" title="Example: 1 if the plug is on for one hour per day.">Number of hours this plug should be ON per cycle.</small>
          </div>
          <div class="col">
            <input type="number" class="form-control plugTotalHours" placeholder="Total Hours" min="1" value="${plugData ? plugData.totalHours : 7}" data-toggle="tooltip" title="Enter the total number of hours in each cycle (e.g., 7 for a 7‑hour cycle).">
            <small class="form-text" data-toggle="tooltip" title="This sets the length of each cycle.">Total hours in each cycle (e.g., 7 hours).</small>
          </div>
          <div class="col">
            <input type="number" class="form-control plugKwh" placeholder="kWh" min="0" value="${plugData ? plugData.kwh : 1}" data-toggle="tooltip" title="Enter the device power consumption (in kWh).">
            <small class="form-text" data-toggle="tooltip" title="Example: 1.5 if the device uses 1.5 kWh when ON.">Power consumption in kWh when the plug is ON.</small>
          </div>
        </div>
        <div class="form-group mt-2">
          <input type="text" class="form-control webhookOn" placeholder="Webhook URL for ON" value="${plugData ? plugData.webhookOn : ""}" data-toggle="tooltip" title="Enter the URL that triggers turning the plug ON.">
          <small class="form-text" data-toggle="tooltip" title="This webhook is called to switch the plug on.">Enter the webhook URL to turn this plug ON.</small>
          <button type="button" class="btn btn-sm btn-secondary testWebhookOn mt-1" data-toggle="tooltip" title="Click to test the ON webhook.">Test ON Webhook</button>
        </div>
        <div class="form-group">
          <input type="text" class="form-control webhookOff" placeholder="Webhook URL for OFF" value="${plugData ? plugData.webhookOff : ""}" data-toggle="tooltip" title="Enter the URL that triggers turning the plug OFF.">
          <small class="form-text" data-toggle="tooltip" title="This webhook is called to switch the plug off.">Enter the webhook URL to turn this plug OFF.</small>
          <button type="button" class="btn btn-sm btn-secondary testWebhookOff mt-1" data-toggle="tooltip" title="Click to test the OFF webhook.">Test OFF Webhook</button>
        </div>
        <button type="button" class="btn btn-danger btn-sm deletePlug" data-toggle="tooltip" title="Click to remove this plug configuration.">Delete Plug</button>
        <div class="plugStatus" style="margin-top:5px;" data-toggle="tooltip" title="This displays the current status of the plug.">Status: UNKNOWN</div>
        <button class="btn btn-sm btn-info mt-2 toggleAdvancedSettings" type="button" data-toggle="collapse" data-target="#advancedSettings-${plugIndex}" data-toggle="tooltip" title="Click to view advanced settings for this plug.">Toggle Advanced Settings</button>
        <div class="collapse plugAdvancedSettings" id="advancedSettings-${plugIndex}">
          <div class="forcedScheduleSection mt-2">
            <h5>Forced Schedule Settings</h5>
            <div class="forcedRulesContainer"></div>
            <button type="button" class="btn btn-secondary btn-sm addForcedRule" data-toggle="tooltip" title="Click to add a forced rule for this plug.">Add Forced Rule</button>
            <small class="form-text" data-toggle="tooltip" title="Forced rules override the computed schedule at specified times.">Define forced on/off rules (select multiple days if needed, and set the same hours for them).</small>
          </div>
          <div class="historyLogSection mt-3">
            <h5>History Log</h5>
            <table class="table table-sm historyLogTable">
              <thead>
                <tr>
                  <th>Time</th>
                  <th>Status</th>
                  <th>Duration</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
      `;
      plugList.appendChild(plugDiv);
      
      plugDiv.historyLog = [];
      
      plugDiv.querySelector('.deletePlug').addEventListener('click', function() {
        plugList.removeChild(plugDiv);
      });
      
      plugDiv.querySelector('.testWebhookOn').addEventListener('click', function() {
        const webhook = plugDiv.querySelector('.webhookOn').value;
        if (webhook) { const img = new Image(); img.src = webhook; console.log("Called webhook ON: " + webhook); }
        else { alert("Please enter a webhook URL for ON"); }
      });
      plugDiv.querySelector('.testWebhookOff').addEventListener('click', function() {
        const webhook = plugDiv.querySelector('.webhookOff').value;
        if (webhook) { const img = new Image(); img.src = webhook; console.log("Called webhook OFF: " + webhook); }
        else { alert("Please enter a webhook URL for OFF"); }
      });
      
      plugDiv.querySelector('.addForcedRule').addEventListener('click', function() {
        const container = plugDiv.querySelector('.forcedRulesContainer');
        const ruleDiv = document.createElement('div');
        ruleDiv.className = 'forcedRule row';
        ruleDiv.innerHTML = `
          <div class="col-4">
            <label>Days:</label>
            <select class="form-control forcedRuleDays" multiple size="3" data-toggle="tooltip" title="Select the days this rule applies to.">
              <option value="Mon">Mon</option>
              <option value="Tue">Tue</option>
              <option value="Wed">Wed</option>
              <option value="Thu">Thu</option>
              <option value="Fri">Fri</option>
              <option value="Sat">Sat</option>
              <option value="Sun">Sun</option>
            </select>
          </div>
          <div class="col-3">
            <label>Start Time:</label>
            <input type="time" class="form-control forcedRuleStart" value="08:00" data-toggle="tooltip" title="Set the start time for this rule.">
          </div>
          <div class="col-3">
            <label>End Time:</label>
            <input type="time" class="form-control forcedRuleEnd" value="09:00" data-toggle="tooltip" title="Set the end time for this rule.">
          </div>
          <div class="col-2">
            <label>State:</label>
            <select class="form-control forcedRuleState" data-toggle="tooltip" title="Choose whether to force the plug ON or OFF during this time interval.">
              <option value="on">ON</option>
              <option value="off">OFF</option>
            </select>
          </div>
          <div class="col-12">
            <button type="button" class="btn btn-danger btn-sm removeForcedRule mt-1" data-toggle="tooltip" title="Click to remove this rule.">Remove Rule</button>
          </div>
        `;
        container.appendChild(ruleDiv);
        ruleDiv.querySelector('.removeForcedRule').addEventListener('click', function() { container.removeChild(ruleDiv); });
      });
      
      $(`#advancedSettings-${plugIndex}`).on('shown.bs.collapse', function () { updateHistoryTable(plugDiv); });
      
      if (plugData && plugData.forcedRules) {
        plugData.forcedRules.forEach(rule => {
          const container = plugDiv.querySelector('.forcedRulesContainer');
          const ruleDiv = document.createElement('div');
          ruleDiv.className = 'forcedRule row';
          ruleDiv.innerHTML = `
            <div class="col-4">
              <label>Days:</label>
              <select class="form-control forcedRuleDays" multiple size="3" data-toggle="tooltip" title="Select the days this rule applies to.">
                <option value="Mon">Mon</option>
                <option value="Tue">Tue</option>
                <option value="Wed">Wed</option>
                <option value="Thu">Thu</option>
                <option value="Fri">Fri</option>
                <option value="Sat">Sat</option>
                <option value="Sun">Sun</option>
              </select>
            </div>
            <div class="col-3">
              <label>Start Time:</label>
              <input type="time" class="form-control forcedRuleStart" value="${rule.start}" data-toggle="tooltip" title="Start time for this rule.">
            </div>
            <div class="col-3">
              <label>End Time:</label>
              <input type="time" class="form-control forcedRuleEnd" value="${rule.end}" data-toggle="tooltip" title="End time for this rule.">
            </div>
            <div class="col-2">
              <label>State:</label>
              <select class="form-control forcedRuleState" data-toggle="tooltip" title="Force the plug ON or OFF during this period.">
                <option value="on" ${rule.state === "on" ? "selected" : ""}>ON</option>
                <option value="off" ${rule.state === "off" ? "selected" : ""}>OFF</option>
              </select>
            </div>
            <div class="col-12">
              <button type="button" class="btn btn-danger btn-sm removeForcedRule mt-1" data-toggle="tooltip" title="Remove this rule.">Remove Rule</button>
            </div>
          `;
          container.appendChild(ruleDiv);
          ruleDiv.querySelector('.removeForcedRule').addEventListener('click', function() { container.removeChild(ruleDiv); });
        });
      }
    }
    
    document.getElementById('addPlugBtn').addEventListener('click', function() { addPlug(); });
    
    function updateHistoryTable(plugEntry) {
      const tableBody = plugEntry.querySelector('.historyLogTable tbody');
      tableBody.innerHTML = "";
      if (plugEntry.historyLog && plugEntry.historyLog.length > 0) {
        plugEntry.historyLog.forEach((entry, i) => {
          let durationText = "";
          if (i > 0 && plugEntry.historyLog[i - 1].timestamp) {
            const diff = entry.timestamp - plugEntry.historyLog[i - 1].timestamp;
            const hours = Math.floor(diff / 3600000);
            const minutes = Math.floor((diff % 3600000) / 60000);
            durationText = `${hours}h ${minutes}m`;
          }
          const row = document.createElement('tr');
          row.innerHTML = `<td>${entry.time}</td><td>${entry.state}</td><td>${durationText}</td>`;
          tableBody.appendChild(row);
        });
      } else {
        const row = document.createElement('tr');
        row.innerHTML = `<td colspan="3">No history available.</td>`;
        tableBody.appendChild(row);
      }
    }
    
    function updatePlugSchedules() {
      if (!weatherTimeData) { alert("Weather data not available yet."); return; }
      const dayGroups = groupTimesByDay(weatherTimeData);
      const plugEntries = document.querySelectorAll('.plugEntry');
      let plugTraces = [];
      let optimalPlugTraces = [];
      const currentWeight = parseInt(document.getElementById('energySlider').value, 10) / 100;
      plugEntries.forEach(entry => {
        const name = entry.querySelector('.plugName').value || "Unnamed Plug";
        const onHours = parseInt(entry.querySelector('.plugOnHours').value, 10);
        const totalHours = parseInt(entry.querySelector('.plugTotalHours').value, 10);
        const kwh = parseFloat(entry.querySelector('.plugKwh').value);
        let uniformSchedule = [];
        let optimalSchedule = [];
        dayGroups.forEach(group => {
          const dayUniform = computePlugScheduleForDay(onHours, totalHours, group.times);
          const dayOptimal = computeOptimalPlugScheduleForDay(onHours, totalHours, group, currentWeight);
          uniformSchedule = uniformSchedule.concat(dayUniform);
          optimalSchedule = optimalSchedule.concat(dayOptimal);
        });
        uniformSchedule = applyForcedRules(entry, uniformSchedule);
        optimalSchedule = applyForcedRules(entry, optimalSchedule);
        const traceUniform = {
          x: weatherTimeData,
          y: uniformSchedule.map(val => val * kwh),
          type: 'bar',
          name: name,
          marker: { opacity: 0.7 }
        };
        const traceOptimal = {
          x: weatherTimeData,
          y: optimalSchedule.map(val => val * kwh),
          type: 'bar',
          name: "Optimal: " + name,
          marker: { opacity: 0.7, color: 'blue' }
        };
        plugTraces.push(traceUniform);
        optimalPlugTraces.push(traceOptimal);
      });
      const scheduleType = document.querySelector('input[name="scheduleType"]:checked').value;
      let selectedPlugTraces = scheduleType === "user" ? plugTraces : optimalPlugTraces;
      const allTraces = globalLineTraces.concat(selectedPlugTraces);
      globalMergedLayout.barmode = 'stack';
      if (chartInitialized) {
        Plotly.react('mergedGraph', allTraces, globalMergedLayout, { responsive: true });
      } else {
        Plotly.newPlot('mergedGraph', allTraces, globalMergedLayout, { responsive: true });
        chartInitialized = true;
      }
    }
    
    function updateProfitInfographic() {
      if (!weatherTimeData) return;
      const dayGroups = groupTimesByDay(weatherTimeData);
      let totalRescheduledEnergy = 0;
      const plugEntries = document.querySelectorAll('.plugEntry');
      plugEntries.forEach(entry => {
        const kwh = parseFloat(entry.querySelector('.plugKwh').value);
        const onHours = parseInt(entry.querySelector('.plugOnHours').value, 10);
        const totalHours = parseInt(entry.querySelector('.plugTotalHours').value, 10);
        let plugRescheduled = 0;
        dayGroups.forEach(group => {
          const userSched = computePlugScheduleForDay(onHours, totalHours, group.times);
          const optSched = computeOptimalPlugScheduleForDay(onHours, totalHours, group, parseInt(document.getElementById('energySlider').value, 10) / 100);
          const userFinal = applyForcedRules(entry, userSched);
          const optFinal = applyForcedRules(entry, optSched);
          let diffCount = 0;
          for (let i = 0; i < userFinal.length; i++) {
            if (userFinal[i] !== optFinal[i]) diffCount++;
          }
          plugRescheduled += (diffCount / 2) * kwh;
        });
        totalRescheduledEnergy += plugRescheduled;
      });
      const profitDiv = document.getElementById('profitInfographicValue');
      profitDiv.innerHTML = `<p>${totalRescheduledEnergy.toFixed(2)} kWh</p>`;
    }
    
    function checkPlugStates() {
      try {
        if (!weatherTimeData) return;
        const now = new Date();
        let currentIndex = 0;
        let minDiff = Infinity;
        weatherTimeData.forEach((t, i) => {
          const diff = Math.abs(new Date(t) - now);
          if (diff < minDiff) { minDiff = diff; currentIndex = i; }
        });
        const plugEntries = document.querySelectorAll('.plugEntry');
        plugEntries.forEach((entry, idx) => {
          const scheduleType = document.querySelector('input[name="scheduleType"]:checked').value;
          const currentWeight = parseInt(document.getElementById('energySlider').value, 10) / 100;
          const onHours = parseInt(entry.querySelector('.plugOnHours').value, 10);
          const totalHours = parseInt(entry.querySelector('.plugTotalHours').value, 10);
          const dayGroups = groupTimesByDay(weatherTimeData);
          let schedule = [];
          dayGroups.forEach(group => {
            if (scheduleType === "user") {
              schedule = schedule.concat(computePlugScheduleForDay(onHours, totalHours, group.times));
            } else {
              schedule = schedule.concat(computeOptimalPlugScheduleForDay(onHours, totalHours, group, currentWeight));
            }
          });
          schedule = applyForcedRules(entry, schedule);
          const desiredState = schedule[currentIndex] === 1;
          let lastState = entry.dataset.state;
          let newState = desiredState ? "on" : "off";
          if (lastState !== newState) {
            if (newState === "on") {
              const webhook = entry.querySelector('.webhookOn').value;
              if (webhook) { const img = new Image(); img.src = webhook; console.log("Triggered ON webhook for plug", idx, webhook); }
            } else {
              const webhook = entry.querySelector('.webhookOff').value;
              if (webhook) { const img = new Image(); img.src = webhook; console.log("Triggered OFF webhook for plug", idx, webhook); }
            }
            entry.dataset.state = newState;
            const logEntry = { time: new Date().toLocaleTimeString(), state: newState.toUpperCase(), timestamp: new Date().getTime() };
            if (!entry.historyLog) entry.historyLog = [];
            entry.historyLog.push(logEntry);
            if (entry.historyLog.length > 50) entry.historyLog.shift();
            updateHistoryTable(entry);
          }
          let statusIndicator = entry.querySelector('.plugStatus');
          if (statusIndicator) { statusIndicator.innerText = "Status: " + newState.toUpperCase(); }
        });
      } catch (error) {
        console.error("Error in checkPlugStates:", error);
      }
    }
    
    setInterval(function() { 
      try {
        checkPlugStates(); 
      } catch (error) {
        console.error("Error in periodic plug state check:", error);
      }
    }, 10000);
    
    function refreshWeather() {
      document.getElementById("locationForm").dispatchEvent(new Event('submit'));
    }
    setInterval(function(){
      try {
        refreshWeather();
      } catch (error) {
        console.error("Error in hourly weather refresh:", error);
      }
    }, 3600000);
    
    setInterval(function() {
      try {
        if (lastWeatherUpdate && (new Date() - lastWeatherUpdate > 55 * 60 * 1000)) {
          console.log("Weather data outdated. Refreshing...");
          refreshWeather();
        }
      } catch (error) {
        console.error("Error in weather safety check:", error);
      }
    }, 60000);
    
    let wakeLock = null;
    async function requestWakeLock() {
      try {
        wakeLock = await navigator.wakeLock.request('screen');
        console.log('Wake Lock is active');
        wakeLock.addEventListener('release', () => {
          console.log('Wake Lock was released');
        });
      } catch (err) {
        console.error(`${err.name}, ${err.message}`);
      }
    }
    function releaseWakeLock() {
      if (wakeLock !== null) {
        wakeLock.release();
        wakeLock = null;
        console.log('Wake Lock released');
      }
    }
    
    document.getElementById('preventScreensaverToggle').addEventListener('change', function() {
      if (this.checked) { requestWakeLock(); }
      else { releaseWakeLock(); }
    });
    
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible' && document.getElementById('preventScreensaverToggle').checked && !wakeLock) {
        requestWakeLock();
      }
    });
    
    document.getElementById('updatePlugsBtn').addEventListener('click', function() {
      updatePlugSchedules();
      checkPlugStates();
      updateProfitInfographic();
    });
    
    window.onerror = function(message, source, lineno, colno, error) {
      console.error("Global error caught:", message, source, lineno, colno, error);
      setTimeout(function() {
        location.reload();
      }, 5000);
      return false;
    };
    
    // Overall Settings: change font family and size on the fly.
    document.getElementById('fontSelect').addEventListener('change', function() {
      document.body.style.fontFamily = this.value;
    });
    
    document.getElementById('fontSizeRange').addEventListener('input', function() {
      const size = this.value + "px";
      document.body.style.fontSize = size;
      document.getElementById('fontSizeDisplay').innerText = size;
    });
  </script>
</body>
</html>
